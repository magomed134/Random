import os
import sys
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import SymbolTableSection
from elftools.elf.constants import SH_FLAGS
import pefile
from capstone import *
try:
    from pymacholib import MachO
    MACHO_SUPPORT = True
except ImportError:
    MACHO_SUPPORT = False

ARCH_MAP = {
    'EM_ARM': (CS_ARCH_ARM, CS_MODE_ARM),
    'EM_AARCH64': (CS_ARCH_ARM64, CS_MODE_ARM),
    'EM_386': (CS_ARCH_X86, CS_MODE_32),
    'EM_X86_64': (CS_ARCH_X86, CS_MODE_64),
    'EM_MIPS': (CS_ARCH_MIPS, CS_MODE_MIPS32),
    'EM_RISCV': (CS_ARCH_RISCV, CS_MODE_RISCV32),
    'EM_PPC': (CS_ARCH_PPC, CS_MODE_32)
}

COND_JUMPS = {
    'JE': '==', 'JNE': '!=', 'JL': '<', 'JLE': '<=', 'JG': '>', 'JGE': '>=',
    'JA': '>', 'JAE': '>=', 'JB': '<', 'JBE': '<=',
    'BEQ': '==', 'BNE': '!=', 'BLT': '<', 'BLE': '<=', 'BGT': '>', 'BGE': '>=',
    'CBZ': '== 0', 'CBNZ': '!= 0', 'B.EQ': '==', 'B.NE': '!=', 'B.LT': '<', 'B.GT': '>',
    'BHI': '>', 'BLS': '<=', 'BCS': '>=', 'BCC': '<', 'BMI': '< 0', 'BPL': '>= 0'
}

REG_MAP_ARM64 = {f'x{i}': f'v{i}' for i in range(31)}
REG_MAP_ARM64.update({f'w{i}': f'v{i}' for i in range(31)})
REG_MAP_ARM64['sp'] = 'sp'
REG_MAP_ARM64['xzr'] = '0'
REG_MAP_ARM64['wzr'] = '0'
REG_MAP_ARM64['lr'] = 'lr'
REG_MAP_ARM64['pc'] = 'pc'

HEADER_TEXT = """Generated by GenIda 0.1 beta
Author: @REAL_MAFIAS

"""

def detect_format_and_arch(filepath):
    ext = os.path.splitext(filepath)[1].lower()
    if ext == '.so':
        return 'elf', parse_elf_arch(filepath)
    elif ext in ['.exe', '.dll']:
        return 'pe', parse_pe_arch(filepath)
    elif ext == '.dylib' and MACHO_SUPPORT:
        return 'macho', parse_macho_arch(filepath)
    return None, None

def parse_elf_arch(filepath):
    try:
        with open(filepath, 'rb') as f:
            elf = ELFFile(f)
            return elf.header['e_machine']
    except:
        return None

def parse_pe_arch(filepath):
    try:
        pe = pefile.PE(filepath)
        machine = pe.FILE_HEADER.Machine
        if machine == 0x014c:
            return 'EM_386'
        elif machine == 0x8664:
            return 'EM_X86_64'
        return None
    except:
        return None

def parse_macho_arch(filepath):
    if not MACHO_SUPPORT:
        return None
    try:
        m = MachO.MachO(filepath)
        for header in m.headers:
            cpu = header.cputype
            if cpu == 12:
                return 'EM_ARM'
            elif cpu == 0x0100000c:
                return 'EM_AARCH64'
            elif cpu == 7:
                return 'EM_386'
            elif cpu == 0x01000007:
                return 'EM_X86_64'
            elif cpu == 18:
                return 'EM_PPC'
        return None
    except:
        return None

def get_symbols(fmt, filepath):
    symbols = {}
    dyn_symbols = {}
    if fmt == 'elf':
        try:
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                for section in elf.iter_sections():
                    if isinstance(section, SymbolTableSection):
                        for sym in section.iter_symbols():
                            if sym['st_info']['type'] in ['STT_FUNC', 'STT_NOTYPE']:
                                if sym.name:
                                    symbols[sym.name] = sym['st_value']
                            if section.name == '.dynsym' and sym.name:
                                dyn_symbols[sym.name] = sym['st_value']
        except:
            pass
    elif fmt == 'pe':
        try:
            pe = pefile.PE(filepath)
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        symbols[exp.name.decode()] = exp.address + pe.OPTIONAL_HEADER.ImageBase
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for imp in pe.DIRECTORY_ENTRY_IMPORT:
                    for i in imp.imports:
                        if i.name:
                            dyn_symbols[i.name.decode()] = 0
        except:
            pass
    elif fmt == 'macho':
        if MACHO_SUPPORT:
            try:
                m = MachO.MachO(filepath)
                for header in m.headers:
                    for cmd in header.commands:
                        if cmd[0].get_cmd_name() == 'LC_SYMTAB':
                            symtab = cmd[2]
                            for sym in symtab.syms:
                                if (sym.n_type & 0x0e) == 0x0e:
                                    name = sym.name.strip('_')
                                    symbols[name] = sym.n_value
            except:
                pass
    return symbols, dyn_symbols

def get_strings(fmt, filepath):
    strings = {}
    if fmt == 'elf':
        try:
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                for section in elf.iter_sections():
                    if section['sh_type'] == 'SHT_PROGBITS' and (section['sh_flags'] & SH_FLAGS.SHF_ALLOC) and not (section['sh_flags'] & SH_FLAGS.SHF_EXECINSTR):
                        data = section.data()
                        start = 0
                        while start < len(data):
                            end = data.find(b'\x00', start)
                            if end == -1:
                                end = len(data)
                            str_val = data[start:end].decode(errors='ignore')
                            if len(str_val) > 3:
                                addr = section['sh_addr'] + start
                                strings[addr] = str_val
                            if end == len(data):
                                break
                            start = end + 1
        except:
            pass
    elif fmt == 'pe':
        try:
            pe = pefile.PE(filepath)
            for section in pe.sections:
                if b'.rdata' in section.Name or b'.data' in section.Name:
                    data = section.get_data()
                    start = 0
                    while start < len(data):
                        end = data.find(b'\x00', start)
                        if end == -1:
                            end = len(data)
                        str_val = data[start:end].decode(errors='ignore')
                        if len(str_val) > 3:
                            addr = pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress + start
                            strings[addr] = str_val
                        if end == len(data):
                            break
                        start = end + 1
        except:
            pass
    elif fmt == 'macho':
        if MACHO_SUPPORT:
            try:
                m = MachO.MachO(filepath)
                for header in m.headers:
                    for seg, sec, sec_data in header.sections:
                        if sec.sectname.strip(b'\x00') == b'__cstring':
                            data = sec_data
                            start = 0
                            while start < len(data):
                                end = data.find(b'\x00', start)
                                if end == -1:
                                    end = len(data)
                                str_val = data[start:end].decode(errors='ignore')
                                if len(str_val) > 3:
                                    addr = sec.addr + start
                                    strings[addr] = str_val
                                if end == len(data):
                                    break
                                start = end + 1
            except:
                pass
    return strings

def get_constants(fmt, filepath):
    constants = {}
    if fmt == 'elf':
        try:
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                for section in elf.iter_sections():
                    if section['sh_type'] == 'SHT_PROGBITS' and '.rodata' in section.name:
                        data = section.data()
                        for i in range(0, len(data), 4):
                            if i + 4 > len(data):
                                break
                            val = int.from_bytes(data[i:i+4], 'little')
                            if 0 < val < 0x1000000:
                                addr = section['sh_addr'] + i
                                constants[addr] = val
        except:
            pass
    elif fmt == 'pe':
        try:
            pe = pefile.PE(filepath)
            for section in pe.sections:
                if b'.rdata' in section.Name:
                    data = section.get_data()
                    for i in range(0, len(data), 4):
                        if i + 4 > len(data):
                            break
                        val = int.from_bytes(data[i:i+4], 'little')
                        if 0 < val < 0x1000000:
                            addr = pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress + i
                            constants[addr] = val
        except:
            pass
    return constants

def get_globals(fmt, filepath):
    globals = {}
    if fmt == 'elf':
        try:
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                for section in elf.iter_sections():
                    if section.name in ['.data', '.bss']:
                        data = section.data()
                        for i in range(0, len(data), 8):
                            if i + 8 > len(data):
                                break
                            val = int.from_bytes(data[i:i+8], 'little', signed=True)
                            if val != 0:
                                addr = section['sh_addr'] + i
                                globals[addr] = f'dword_{addr:08x}'
        except:
            pass
    return globals

def get_code_section(fmt, filepath):
    if fmt == 'elf':
        try:
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                code_data = b''
                base_addr = 0
                for section in elf.iter_sections():
                    if section['sh_flags'] & SH_FLAGS.SHF_EXECINSTR and '.text' in section.name:
                        f.seek(section['sh_offset'])
                        code_data += f.read(section['sh_size'])
                        base_addr = section['sh_addr']
                return code_data, base_addr
        except:
            pass
    elif fmt == 'pe':
        try:
            pe = pefile.PE(filepath)
            code_data = b''
            base_addr = pe.OPTIONAL_HEADER.ImageBase
            for section in pe.sections:
                if section.Characteristics & 0x20:
                    code_data += pe.get_data(section.VirtualAddress, section.Misc_VirtualSize)
            return code_data, base_addr
        except:
            pass
    elif fmt == 'macho':
        if MACHO_SUPPORT:
            try:
                m = MachO.MachO(filepath)
                code_data = b''
                base_addr = 0
                for header in m.headers:
                    for seg, sec, data in header.sections:
                        if sec.sectname.strip(b'\x00') == b'__text':
                            code_data += data
                            base_addr = sec.addr
                return code_data, base_addr
            except:
                pass
    return b'', 0

def disassemble_code(code, base_addr, arch_key, mode_adjust=0):
    if arch_key not in ARCH_MAP:
        return []
    arch, mode = ARCH_MAP[arch_key]
    mode |= mode_adjust
    try:
        md = Cs(arch, mode)
        md.detail = True
        return list(md.disasm(code, base_addr))
    except:
        return []

def build_cfg(instructions):
    cfg = {}
    addr_to_idx = {instr.address: i for i, instr in enumerate(instructions)}
    for i, instr in enumerate(instructions):
        addr = instr.address
        cfg[addr] = {'next': None, 'branches': [], 'calls': []}
        if instr.group(CS_GRP_JUMP):
            if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM:
                target = instr.operands[-1].imm
                cfg[addr]['branches'].append(target)
        if instr.group(CS_GRP_CALL):
            if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM:
                target = instr.operands[-1].imm
                cfg[addr]['calls'].append(target)
        if i + 1 < len(instructions):
            cfg[addr]['next'] = instructions[i+1].address
    return cfg

def generate_asm(instructions, symbols, dyn_symbols, arch_key, strings, cfg):
    asm_lines = []
    rev_symbols = {v: k for k, v in {**symbols, **dyn_symbols}.items()}
    labels = {}
    for instr in instructions:
        if instr.group(CS_GRP_JUMP) or instr.group(CS_GRP_CALL):
            if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM:
                target = instr.operands[-1].imm
                if target not in labels and target not in rev_symbols:
                    labels[target] = f'loc_{target:08x}'
    for instr in instructions:
        addr = instr.address
        if addr in labels:
            asm_lines.append(f'{labels[addr]}:')
        is_64bit = '64' in str(ARCH_MAP[arch_key][1])
        addr_str = f'{addr:016x}' if is_64bit else f'{addr:08x}'
        bytes_str = ' '.join(f'{b:02x}' for b in instr.bytes)
        op_str = instr.op_str
        comment = ''
        if instr.group(CS_GRP_CALL):
            target = 0
            if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM:
                target = instr.operands[-1].imm
            if target in rev_symbols:
                op_str = op_str.replace(hex(target), rev_symbols[target])
                comment += f' ; call {rev_symbols[target]}'
            elif target in labels:
                op_str = op_str.replace(hex(target), labels[target])
        elif instr.group(CS_GRP_JUMP):
            target = 0
            if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM:
                target = instr.operands[-1].imm
                if target in labels:
                    op_str = op_str.replace(hex(target), labels[target])
                comment += f' ; branch to {hex(target)}'
        if addr in strings:
            comment += f' ; strref "{strings[addr][:20]}..."'
        if addr in cfg:
            branches = len(cfg[addr]['branches'])
            if branches > 3:
                comment += f' ; switch-like (branches: {branches})'
        if instr.mnemonic in ['ADD', 'SUB', 'MUL', 'LDRB', 'LDRH', 'STRB', 'STRH', 'LD1', 'ST1']:
            parts = op_str.split(',')
            if parts:
                dst = parts[0].strip()
                comment += f' ; {REG_MAP_ARM64.get(dst, dst)} = {op_str}'
        line = f'{addr_str}: {bytes_str.ljust(20)} {instr.mnemonic} {op_str}{comment}'
        if addr in rev_symbols:
            asm_lines.append(f'{rev_symbols[addr]} proc near')
        asm_lines.append(line)
        if addr in rev_symbols:
            asm_lines.append(f'{rev_symbols[addr]} endp')
    return '\n'.join(asm_lines)

def resolve_operand(operand, reg_map, strings, constants, globals, macros, addr=None, var_types={}):
    if operand.startswith('#'):
        operand = operand[1:]
    if operand.isdigit() or operand.startswith('0x'):
        try:
            imm = int(operand, 0)
            if imm in strings:
                var_types[operand] = 'char*'
                return f'"{strings[imm]}"'
            elif imm in constants:
                const_name = f'CONST_{imm:04x}'
                if const_name not in macros:
                    macros[const_name] = constants[imm]
                var_types[operand] = 'int'
                return const_name
            elif imm in globals:
                var_types[operand] = 'long'
                return globals[imm]
            var_types[operand] = 'int'
            return str(imm)
        except ValueError:
            pass
    reg_var = reg_map.get(operand, operand)
    return reg_var

def infer_var_type(op, src1_type, src2_type):
    if 'F' in op.upper() or 'CMP' in op.upper():
        return 'double'
    if 'B' in op or 'H' in op:
        return 'char' if 'B' in op else 'short'
    if src1_type == 'char*' or src2_type == 'char*':
        return 'char*'
    return 'long'

def dead_code_elimination(instructions, cfg):
    live_addrs = set()
    for addr in reversed(list(cfg.keys())):
        if cfg[addr]['next']:
            live_addrs.add(cfg[addr]['next'])
        for branch in cfg[addr]['branches']:
            live_addrs.add(branch)
        for call in cfg[addr]['calls']:
            live_addrs.add(call)
        live_addrs.add(addr)
    return [instr for instr in instructions if instr.address in live_addrs]

def generate_pseudo_c(instructions, arch_key, symbols, dyn_symbols, strings, constants, globals, cfg):
    instructions = dead_code_elimination(instructions, cfg)
    c_lines = ['#include <stdio.h>', '#include <stdlib.h>', '#include <dlfcn.h>']
    prototypes = []
    macros = {}
    var_types = {}
    var_map = {}
    stack = []
    block_stack = []
    arg_stack = []
    var_count = 1
    func_name = ''
    i = 0
    max_depth = 100
    depth = 0
    rev_symbols = {v: k for k, v in symbols.items()}
    rev_dyn = {v: k for k, v in dyn_symbols.items()}
    is_64 = arch_key == 'EM_AARCH64'
    var_type = 'long'
    loop_detect = set()
    addr_to_idx = {instr.address: idx for idx, instr in enumerate(instructions)}
    call_map = {}
    for instr in instructions:
        if instr.group(CS_GRP_CALL):
            target = instr.operands[-1].imm if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM else 0
            call_map[target] = rev_symbols.get(target, rev_dyn.get(target, f'sub_{target:08x}'))
    switch_tables = {}
    offset_patterns = {}  # Для структур/массивов
    for addr, data in cfg.items():
        if len(data['branches']) > 5:
            switch_tables[addr] = data['branches']
    struct_globals = 'struct Globals {\n' + '\n'.join([f'    long {name};\n' for name in globals.values()]) + '};'
    c_lines.append(struct_globals)
    c_lines.append('struct Globals globals = {0};')
    c_lines.append('')
    while i < len(instructions) and depth < max_depth:
        try:
            instr = instructions[i]
            op = instr.mnemonic.upper()
            args = instr.op_str
            indent_level = len(block_stack)
            indent = '    ' * indent_level
            addr = instr.address
            if addr in rev_symbols:
                if func_name:
                    c_lines.append('')
                    while block_stack:
                        c_lines.append('    ' * len(block_stack) + '}')
                        block_stack.pop()
                    c_lines.append('')
                    c_lines.append('}')
                    c_lines.append('')
                    c_lines.append('')
                    c_lines.append('')
                    c_lines.append('')
                func_name = rev_symbols[addr] or f'sub_{addr:08x}'
                prototypes.append(f'{var_type} {func_name}(void);')
                c_lines.append(f'{var_type} {func_name}(void)')
                c_lines.append('{')
                var_map = {'x0': 'arg0', 'x1': 'arg1', 'x2': 'arg2', 'x3': 'arg3'}
                var_types = {'arg0': 'long', 'arg1': 'long', 'arg2': 'long', 'arg3': 'long'}
                var_count = 4
                stack = []
                arg_stack = []
                block_stack = []
                c_lines.append('')
            if instr.group(CS_GRP_CALL) or 'BL' in op:
                target = instr.operands[-1].imm if len(instr.operands) > 0 and instr.operands[-1].type == CS_OP_IMM else 0
                func_call = call_map.get(target, f'sub_{target:08x}')
                call_args = ', '.join([var_map.get(reg, reg) for reg in arg_stack[-8:][::-1]]) if arg_stack else 'void'
                c_lines.append(f'{indent}{func_call}({call_args});')
                arg_stack = arg_stack[:-8] if len(arg_stack) > 8 else []
                i += 1
                continue
            if arch_key == 'EM_AARCH64':
                reg_map = REG_MAP_ARM64
                parts = [p.strip() for p in args.split(',')]
                if op in ['MOV', 'ADR', 'FMOV', 'LDRB', 'LDRH', 'LD1']:
                    dst = parts[0]
                    src = parts[1] if len(parts) > 1 else '0'
                    dst_var = var_map.get(dst, f'counter' if i > 0 and instructions[i-1].mnemonic == 'ADD' else f'ptr{var_count}')
                    if dst not in var_map:
                        inferred_type = infer_var_type(op, var_types.get(src, 'long'), 'long')
                        var_map[dst] = dst_var
                        var_types[dst_var] = inferred_type
                        var_count += 1
                        c_lines.append(f'{indent}{inferred_type} {dst_var};')
                    src_var = resolve_operand(src, reg_map, strings, constants, globals, macros, addr, var_types)
                    c_lines.append(f'{indent}{dst_var} = {src_var};')
                elif op in ['ADD', 'SUB', 'FADD', 'FSUB']:
                    dst = parts[0]
                    src1 = parts[1]
                    src2 = parts[2].lstrip('#') if len(parts) > 2 else '0'
                    op_c = '+' if op in ['ADD', 'FADD'] else '-'
                    dst_var = var_map.get(dst, f'counter' if int(src2, 0) == 1 else f'result{var_count}')
                    if dst not in var_map:
                        inferred_type = infer_var_type(op, var_types.get(src1, 'long'), var_types.get(src2, 'long'))
                        var_map[dst] = dst_var
                        var_types[dst_var] = inferred_type
                        var_count += 1
                        c_lines.append(f'{indent}{inferred_type} {dst_var} = {var_map.get(src1, src1)} {op_c} {src2};')
                    else:
                        c_lines.append(f'{indent}{dst_var} = {var_map.get(src1, src1)} {op_c} {src2};')
                elif op in ['MUL', 'UDIV', 'SDIV', 'FMUL', 'FDIV']:
                    dst = parts[0]
                    src1 = parts[1]
                    src2 = parts[2]
                    op_c = {'MUL':'*', 'UDIV':'/', 'SDIV':'/', 'FMUL':'*', 'FDIV':'/'}[op]
                    dst_var = var_map.get(dst, f'result{var_count}')
                    if dst not in var_map:
                        inferred_type = infer_var_type(op, var_types.get(src1, 'long'), var_types.get(src2, 'long'))
                        var_map[dst] = dst_var
                        var_types[dst_var] = inferred_type
                        var_count += 1
                        c_lines.append(f'{indent}{inferred_type} {dst_var} = {var_map.get(src1, src1)} {op_c} {var_map.get(src2, src2)};')
                    else:
                        c_lines.append(f'{indent}{dst_var} = {var_map.get(src1, src1)} {op_c} {var_map.get(src2, src2)};')
                elif op in ['LSL', 'LSR', 'ASR']:
                    dst = parts[0]
                    src1 = parts[1]
                    src2 = int(parts[2].lstrip('#'), 0) if len(parts) > 2 else 0
                    op_c = {'LSL':'<<', 'LSR': '>>', 'ASR': '>>'}[op]
                    dst_var = var_map.get(dst, f'shifted_var{var_count}')
                    if dst not in var_map:
                        var_map[dst] = dst_var
                        var_types[dst_var] = 'long'
                        var_count += 1
                        c_lines.append(f'{indent}{var_type} {dst_var} = {var_map.get(src1, src1)} {op_c} {src2};')
                    else:
                        c_lines.append(f'{indent}{dst_var} = {var_map.get(src1, src1)} {op_c} {src2};')
                elif op in ['AND', 'ORR', 'EOR']:
                    dst = parts[0]
                    src1 = parts[1]
                    src2 = parts[2]
                    op_c = {'AND':'&', 'ORR':'|', 'EOR':'^'}[op]
                    dst_var = var_map.get(dst, f'mask_var{var_count}')
                    if dst not in var_map:
                        var_map[dst] = dst_var
                        var_types[dst_var] = 'long'
                        var_count += 1
                        c_lines.append(f'{indent}{var_type} {dst_var} = {var_map.get(src1, src1)} {op_c} {var_map.get(src2, src2)};')
                    else:
                        c_lines.append(f'{indent}{dst_var} = {var_map.get(src1, src1)} {op_c} {var_map.get(src2, src2)};')
                elif op == 'FCMP':
                    left = parts[0]
                    right = parts[1].lstrip('#') if len(parts) > 1 else '0'
                    left_var = resolve_operand(left, reg_map, strings, constants, globals, macros, var_types)
                    right_var = resolve_operand(right, reg_map, strings, constants, globals, macros, var_types)
                    c_lines.append(f'{indent}if ( {left_var} == {right_var} ) {{')
                    block_stack.append('if')
                elif op.startswith('B.') and '.' in op:
                    cond = op.split('.')[1]
                    target_str = args
                    try:
                        target = int(target_str, 16)
                    except:
                        target = 0
                    if target in addr_to_idx:
                        cond_op = COND_JUMPS.get(f'B.{cond}', '== 0')
                        if cond_op != '':
                            if ',' in args:
                                left_part, right_part = [p.strip() for p in args.split(',')]
                                left_var = resolve_operand(left_part, reg_map, strings, constants, globals, macros, var_types)
                                right_var = resolve_operand(right_part, reg_map, strings, constants, globals, macros, var_types)
                            else:
                                left_var = resolve_operand(parts[0], reg_map, strings, constants, globals, macros, var_types)
                                right_var = '0'
                            c_lines.append(f'{indent}if ( {left_var} {cond_op} {right_var} ) {{')
                            block_stack.append('if')
                            i = addr_to_idx[target] - 1
                            continue
                elif op in ['CBZ', 'CBNZ']:
                    reg = parts[0]
                    target_str = parts[1]
                    try:
                        target = int(target_str, 16)
                    except:
                        target = 0
                    if target in addr_to_idx:
                        cond_op = COND_JUMPS.get(op, '== 0')
                        reg_var = resolve_operand(reg, reg_map, strings, constants, globals, macros, var_types)
                        c_lines.append(f'{indent}if ( {reg_var} {cond_op} ) {{')
                        block_stack.append('if')
                        i = addr_to_idx[target] - 1
                        continue
                elif op == 'B':
                    target_str = args
                    try:
                        target = int(target_str, 16)
                    except:
                        target = 0
                    if target in addr_to_idx:
                        if target < addr and target not in loop_detect:
                            c_lines.append(f'{indent}do {{')
                            block_stack.append('do')
                            loop_detect.add(target)
                            i = addr_to_idx[target] - 1
                            continue
                        elif target > addr:
                            c_lines.append(f'{indent}goto loc_{target:08x};')
                    if block_stack and len(block_stack) > 0:
                        last_block = block_stack[-1]
                        if last_block in ['if', 'do']:
                            c_lines.append(f'{indent}}}')
                            if last_block == 'if':
                                c_lines.append(f'{indent}else {{')
                                block_stack[-1] = 'else'
                            else:
                                c_lines.append(f'{indent}}} while (1);')
                                block_stack.pop()
                if addr in switch_tables:
                    cases = switch_tables[addr]
                    c_lines.append(f'{indent}switch (counter) {{')
                    for case in cases[:10]:
                        c_lines.append(f'{indent}    case {hex(case)}:')
                        c_lines.append(f'{indent}        goto loc_{case:08x};')
                    c_lines.append(f'{indent}}}')
                elif op in ['LDR', 'STR', 'LDRB', 'STRB', 'LDRH', 'STRH', 'LD1', 'ST1']:
                    dst = parts[0]
                    mem = parts[1].replace('[', '').replace(']', '')
                    offset = 0
                    if ',' in mem:
                        mem, offset_str = [x.strip() for x in mem.split(',')]
                        offset = int(offset_str.lstrip('#'), 0) if offset_str.lstrip('#').isdigit() else 0
                    mem_var = resolve_operand(mem, reg_map, strings, constants, globals, macros, var_types)
                    dst_var = var_map.get(dst, f'arr[{offset}]{var_count}' if offset > 0 else f'v{var_count}')
                    if dst not in var_map:
                        inferred_type = infer_var_type(op, '', '')
                        if offset > 0 and 'STR' in op:
                            array_size = 3 if offset <= 8 else 10
                            var_map[dst] = f'{dst_var}[{array_size}]'
                            var_types[dst_var] = inferred_type
                            c_lines.append(f'{indent}{inferred_type} {dst_var}[{array_size}] = {{0}};')
                        else:
                            var_map[dst] = dst_var
                            var_types[dst_var] = inferred_type
                            var_count += 1
                            c_lines.append(f'{indent}{inferred_type} {dst_var};')
                    load_addr = addr + 4 + offset if 'pc' in mem.lower() else None
                    if load_addr and load_addr in strings:
                        c_lines.append(f'{indent}{dst_var} = "{strings[load_addr]}";')
                        i += 1
                        continue
                    elif load_addr and load_addr in constants:
                        const_name = f'CONST_{load_addr:04x}'
                        if const_name not in macros:
                            macros[const_name] = constants[load_addr]
                        c_lines.append(f'{indent}{dst_var} = {const_name};')
                        i += 1
                        continue
                    elif load_addr and load_addr in globals:
                        c_lines.append(f'{indent}{dst_var} = globals.{globals[load_addr]};')
                        i += 1
                        continue
                    if op.startswith('LDR') or op == 'LD1':
                        c_lines.append(f'{indent}{dst_var} = *({mem_var} + {offset});')
                    else:
                        c_lines.append(f'{indent}*({mem_var} + {offset}) = {dst_var};')
                elif op in ['STP', 'LDP']:
                    if len(parts) >= 2:
                        reg1 = parts[0].split(',')[0].strip()
                        reg2 = parts[1].split(']')[0].strip().split(',')[0].strip()
                        reg1_var = var_map.get(reg1, reg1)
                        reg2_var = var_map.get(reg2, reg2)
                        if op == 'STP':
                            stack.extend([reg2_var, reg1_var])
                            arg_stack.extend([reg2_var, reg1_var])
                        else:
                            if len(stack) >= 2:
                                popped2 = stack.pop()
                                popped1 = stack.pop()
                                c_lines.append(f'{indent}{reg1_var} = {popped2};')
                                c_lines.append(f'{indent}{reg2_var} = {popped1};')
                elif op in ['MOVZ', 'MOVK']:
                    dst = parts[0]
                    imm = int(parts[1].lstrip('#'), 0)
                    dst_var = var_map.get(dst, f'init_var{var_count}')
                    if dst not in var_map:
                        var_map[dst] = dst_var
                        var_types[dst_var] = 'long'
                        var_count += 1
                        c_lines.append(f'{indent}{var_type} {dst_var} = {imm}{" << 16" if op == "MOVK" else ""};')
                    else:
                        c_lines.append(f'{indent}{dst_var} = {imm}{" << 16" if op == "MOVK" else ""};')
                elif op == 'ADRP':
                    i += 1
                    continue
                elif op == 'RET':
                    ret_val = var_map.get('x0', '0')
                    c_lines.append(f'{indent}return {ret_val};')
                    i += 1
                    continue
            i += 1
            depth += 1
        except IndexError:
            i += 1
            continue
    while block_stack:
        indent = '    ' * len(block_stack)
        c_lines.append(indent + '}')
        block_stack.pop()
    if func_name:
        c_lines.append('}')
        c_lines.append('')
        c_lines.append('')
        c_lines.append('')
        c_lines.append('')
    if prototypes:
        c_lines = prototypes + [''] + c_lines
    macro_lines = [f'#define {name} {val}' for name, val in macros.items()]
    global_lines = [f'{var_type} {name};' for name in globals.values()]
    final_c = '\n'.join(macro_lines) + '\n' + '\n'.join(global_lines) + '\n' + '\n'.join(c_lines)
    return final_c

def check_thumb(arch_key, symbols, dyn_symbols):
    if arch_key == 'EM_ARM':
        for addr in list(symbols.values()) + list(dyn_symbols.values()):
            if addr & 1:
                return CS_MODE_THUMB
    return 0

def main():
    print("GenIda Decompiler 0.1 beta")
    filepath = input("Enter path to .so, .exe, .dll or .dylib: ").strip()
    if not os.path.exists(filepath):
        print("File not found.")
        return
    print("Detecting format and architecture...")
    fmt, arch_key = detect_format_and_arch(filepath)
    if not fmt or not arch_key:
        print("Unsupported format/arch.")
        return
    print("Extracting symbols...")
    symbols, dyn_symbols = get_symbols(fmt, filepath)
    print("Extracting strings...")
    strings = get_strings(fmt, filepath)
    print("Extracting constants...")
    constants = get_constants(fmt, filepath)
    print("Extracting globals...")
    globals_vars = get_globals(fmt, filepath)
    print("Extracting code section...")
    code, base_addr = get_code_section(fmt, filepath)
    if not code:
        print("No code section found.")
        return
    print("Checking Thumb mode...")
    mode_adjust = check_thumb(arch_key, symbols, dyn_symbols)
    print("Disassembling...")
    instructions = disassemble_code(code, base_addr, arch_key, mode_adjust)
    if not instructions:
        print("Disassembly failed.")
        return
    cfg = build_cfg(instructions)
    print("Building CFG...")
    print("Generating ASM...")
    asm_output = generate_asm(instructions, symbols, dyn_symbols, arch_key, strings, cfg)
    print("Generating pseudo C...")
    c_output = generate_pseudo_c(instructions, arch_key, symbols, dyn_symbols, strings, constants, globals_vars, cfg)
    dir_path = os.path.dirname(filepath) or '.'
    base_name = os.path.splitext(os.path.basename(filepath))[0]
    asm_path = os.path.join(dir_path, base_name + '.asm')
    c_path = os.path.join(dir_path, base_name + '.c')
    with open(asm_path, 'w') as f:
        f.write(HEADER_TEXT)
        f.write(asm_output)
    with open(c_path, 'w') as f:
        f.write(HEADER_TEXT)
        f.write(c_output)
    print(f"ASM saved to {asm_path}")
    print(f"C saved to {c_path}")
    print("\nSample C output:\n" + c_output[:500] + "...")

if __name__ == '__main__':
    main()
